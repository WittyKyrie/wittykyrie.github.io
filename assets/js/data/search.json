[ { "title": "反射 Reflection", "url": "/posts/%E5%8F%8D%E5%B0%84/", "categories": "Unity", "tags": "Dependency Injection", "date": "2023-02-27 09:00:00 +0800", "snippet": "反射(Reflection)的概念反射(Reflection)是一种在运行时获取类型信息、动态创建对象、调用方法等操作的机制。在Unity开发过程中，使用反射(Reflection)可以使代码更加灵活和可扩展，例如动态创建对象、动态调用方法和插件化开发等场景。反射(Reflection)的好处与坏处反射(Reflection)是一种强大的机制，可以提高代码的灵活性和可扩展性。但是，在使用反射(Reflection)时需要权衡其优缺点，根据具体情况做出选择，并且需要注意使用反射(Reflection)的最佳实践，以确保代码的性能、安全和可读性。反射(Reflection)的优点 动态加载和实例化对象：使用反射(Reflection)可以在运行时动态地加载和实例化对象，无需在编译时明确指定类型。这样可以提高代码的灵活性和可扩展性，使得代码更加适应变化和复杂性。 动态调用方法和属性：使用反射(Reflection)可以在运行时动态地调用对象的方法和属性，无需在编译时明确指定类型。这样可以使得代码更加适应变化和复杂性，同时也可以简化代码的编写。 插件化开发：使用反射(Reflection)可以实现插件化开发，即动态地加载和卸载插件。这样可以使得应用程序更加灵活和可扩展，同时也可以提高代码的复用性和可维护性。 反射(Reflection)的缺点 性能开销：使用反射(Reflection)会带来一定的性能开销，因为需要在运行时进行类型信息的获取和转换。而且由于需要进行大量的类型检查和字符串匹配，所以在性能上会比直接调用类型和成员信息要慢。因此，在需要高性能的场景下，应尽量避免使用反射(Reflection)。 安全风险：由于反射(Reflection)可以在运行时动态地获取和调用类型和成员信息，所以在某些情况下可能会破坏代码的安全性。例如，可以使用反射(Reflection)来访问私有成员或者调用私有方法，这可能会导致代码的安全漏洞。因此，在使用反射(Reflection)时，需要特别注意代码的安全性。 代码可读性：使用反射(Reflection)会使代码的可读性变差，因为无法在编译时确定对象的类型和方法。如果使用不当，可能会导致代码难以理解和维护。 反射(Reflection)的使用例子以下是一个非常完整的反射(Reflection)的游戏开发过程的例子：假设我们正在开发一个RPG游戏，我们需要动态地加载并实例化不同种类的角色。我们可以使用反射(Reflection)来实现这个功能。首先，我们需要定义一个角色的基类，例如public abstract class Character { public int Health { get; set; } public abstract void Attack();}然后，我们定义不同种类的角色类，例如：public class Warrior : Character { public override void Attack() { Debug.Log(\"Warrior attacks with a sword!\"); }}public class Mage : Character { public override void Attack() { Debug.Log(\"Mage casts a spell!\"); }}public class Archer : Character { public override void Attack() { Debug.Log(\"Archer shoots an arrow!\"); }}接下来，我们可以定义一个角色工厂类，用于动态地加载并实例化不同种类的角色。在这个工厂类中，我们可以使用反射(Reflection)来动态地加载并实例化角色类。public class CharacterFactory { public Character CreateCharacter(string className) { Type type = Type.GetType(className); if (type == null) { Debug.LogError(\"Cannot find class: \" + className); return null; } object instance = Activator.CreateInstance(type); Character character = instance as Character; if (character == null) { Debug.LogError(\"Invalid class type: \" + className); return null; } return character; }}在这个工厂类中，我们首先使用Type.GetType()方法获取角色类的类型。如果无法找到角色类的类型，则返回null。接下来，我们使用Activator.CreateInstance()方法动态地创建角色类的实例。最后，我们将创建的实例强制转换为Character类，并返回该实例。现在，我们可以在游戏中使用CharacterFactory类来动态地加载并实例化不同种类的角色。例如：CharacterFactory factory = new CharacterFactory();Character warrior = factory.CreateCharacter(\"Warrior\");warrior.Attack(); // output: Warrior attacks with a sword!Character mage = factory.CreateCharacter(\"Mage\");mage.Attack(); // output: Mage casts a spell!Character archer = factory.CreateCharacter(\"Archer\");archer.Attack(); // output: Archer shoots an arrow!通过这种方式，我们可以使用反射(Reflection)来实现动态加载和实例化不同种类的角色类。这种方法使得我们的游戏更加灵活和可扩展。与传统的工厂模式相比具有以下的优点： 灵活性：传统的工厂模式需要在代码中显式地列出所有可能创建的对象类型，而动态工厂模式使用反射(Reflection)可以在运行时动态地加载并实例化对象，使得代码更加灵活和可扩展。 可读性：使用传统的工厂模式需要编写大量的if/else语句或者switch语句，用于判断要创建的对象类型，代码可读性不高。而动态工厂模式使用反射(Reflection)可以使代码更加简洁、易读。 维护性：传统的工厂模式需要在代码中显式地列出所有可能创建的对象类型，如果需要添加或删除一个新的对象类型，需要修改代码并重新编译。而动态工厂模式使用反射(Reflection)可以动态地加载并实例化对象，不需要修改代码并重新编译，使得维护更加方便。 但是，反射(Reflection)需要在运行时动态地获取类型信息，并且使用反射(Reflection)创建对象的速度比直接创建对象要慢。因此，在实际开发中，需要权衡使用反射(Reflection)带来的灵活性和性能开销，选择合适的方案。" }, { "title": "游戏设计模式之工厂模式", "url": "/posts/Factor-Pattern/", "categories": "Unity, 设计模式", "tags": "工厂模式", "date": "2023-02-20 09:00:00 +0800", "snippet": "当我们开发游戏时，我们通常需要创建大量的对象。有时候我们需要手动创建这些对象，但是这种方式容易出现错误，而且难以维护和扩展。在这种情况下，工厂模式就变得非常有用。工厂模式是一种创建型设计模式，用于创建对象，将对象的创建过程封装在一个类中，以便在需要时创建对象。工厂模式可以通过将客户端代码与实际创建对象的过程分离来提高代码的可维护性、可扩展性和可读性。在游戏开发中，工厂模式通常用于创建不同类型的游戏对象，例如武器、角色、道具等等。工厂模式的类型在工厂模式中，通常会使用以下三种类型：简单工厂模式简单工厂模式是最基本的工厂模式。在简单工厂模式中，我们只需要一个工厂类，它根据客户端的请求返回一个具体的对象实例。简单工厂模式通常只适用于创建单一的对象类型。工厂方法模式工厂方法模式是一种扩展简单工厂模式的模式，它定义了一个工厂方法接口，用于创建对象，这些对象由子类决定实例化哪一个类。工厂方法模式通常用于创建不同的对象类型，每个对象类型对应一个工厂方法。抽象工厂模式抽象工厂模式是一种创建一组相关或依赖对象的工厂模式。在抽象工厂模式中，客户端请求一个工厂，并从工厂中获取一个产品族中的一个对象。在抽象工厂模式中，工厂不仅仅是一个单独的类，而是一个由多个工厂组成的层次结构。工厂模式的优点 将对象创建过程与客户端代码分离，减少重复代码，提高代码的可维护性和可读性。 隐藏实现细节，避免客户端代码对具体实现的依赖，提高代码的可扩展性。 降低了耦合性，客户端只需要知道需要什么对象，而不需要知道对象的创建细节。 工厂模式的缺点 增加了代码的复杂度，需要创建更多的类。 工厂模式通常需要使用额外的代码来实现，这增加了开发时间和成本。 工厂模式的应用简单工厂模式首先我们创建一个道具的基类public class Item { protected string name; public virtual void use() { Debug.Log(\"使用了\" + name); }}然后，我们可以定义几个具体的道具类，例如 HealthPotion、ManaPotion、SpeedBoost，它们都是 Item 的子类，并且实现了自己特定的 use 方法。public class HealthPotion : Item { public HealthPotion() { name = \"生命药水\"; } public override void use() { base.use(); // 具体的使用逻辑 Debug.Log(\"恢复了100点生命值\"); }}public class ManaPotion : Item { public ManaPotion() { name = \"法力药水\"; } public override void use() { base.use(); // 具体的使用逻辑 Debug.Log(\"恢复了100点法力值\"); }}public class SpeedBoost : Item { public SpeedBoost() { name = \"加速药剂\"; } public override void use() { base.use(); // 具体的使用逻辑 Debug.Log(\"增加了移动速度\"); }}接下来，我们可以定义一个简单工厂类 ItemFactory，该类包含一个用于创建道具的静态方法 CreateItem，根据传入的参数不同，创建不同的道具实例并返回。public class ItemFactory { public static Item CreateItem(string itemName) { Item item = null; if (itemName == \"health_potion\") { item = new HealthPotion(); } else if (itemName == \"mana_potion\") { item = new ManaPotion(); } else if (itemName == \"speed_boost\") { item = new SpeedBoost(); } return item; }}最后，我们可以在游戏中使用 ItemFactory 来创建道具实例并使用它们。// 创建一个生命药水道具Item healthPotion = ItemFactory.CreateItem(\"health_potion\");// 使用生命药水道具healthPotion.use();// 创建一个加速药剂道具Item speedBoost = ItemFactory.CreateItem(\"speed_boost\");// 使用加速药剂道具speedBoost.use();通过使用简单工厂模式，我们可以将道具的创建过程封装在 ItemFactory 类中，使得代码更加清晰，易于维护和扩展。工厂方法模式道具类保持相同，首先我们可以定义一个工厂接口 ItemFactory，该接口包含一个用于创建道具的抽象方法 CreateItem，具体的工厂类实现该方法来创建具体的道具实例。public interface ItemFactory { Item CreateItem();}我们可以针对每种道具类型，创建具体的工厂类，例如 HealthPotionFactory、ManaPotionFactory、SpeedBoostFactory，它们实现了 ItemFactory 接口，并且实现了自己特定的 CreateItem 方法来创建具体的道具实例。public class HealthPotionFactory : ItemFactory { public Item CreateItem() { return new HealthPotion(); }}public class ManaPotionFactory : ItemFactory { public Item CreateItem() { return new ManaPotion(); }}public class SpeedBoostFactory : ItemFactory { public Item CreateItem() { return new SpeedBoost(); }}最后，我们可以在游戏中使用具体的工厂类来创建道具实例并使用它们。// 创建一个生命药水道具ItemFactory healthPotionFactory = new HealthPotionFactory();Item healthPotion = healthPotionFactory.CreateItem();// 使用生命药水道具healthPotion.use();// 创建一个加速药剂道具ItemFactory speedBoostFactory = new SpeedBoostFactory();Item speedBoost = speedBoostFactory.CreateItem();// 使用加速药剂道具speedBoost.use();抽象工厂模式当使用抽象工厂模式时，通常会涉及到一组相关的产品。在游戏开发中，我们可以将不同类型的武器视为相关的产品，使用抽象工厂模式来创建不同种类的武器。我们可以定义一个抽象的武器接口 Weapon，包含攻击方法 attack。然后，我们定义两种不同类型的武器：近战武器和远程武器。为了实现抽象工厂模式，我们需要为每个武器类型定义一个工厂接口，并实现相应的工厂类。// 抽象工厂接口public interface WeaponFactory { MeleeWeapon CreateMeleeWeapon(); RangedWeapon CreateRangedWeapon();}// 近战武器工厂public class MeleeWeaponFactory : WeaponFactory { public MeleeWeapon CreateMeleeWeapon() { return new Sword(); } public RangedWeapon CreateRangedWeapon() { return new NullRangedWeapon(); }}// 远程武器工厂public class RangedWeaponFactory : WeaponFactory { public MeleeWeapon CreateMeleeWeapon() { return new NullMeleeWeapon(); } public RangedWeapon CreateRangedWeapon() { return new Bow(); }}然后我们定义具体的武器类，包括剑 Sword、弓 Bow、空近战武器 NullMeleeWeapon 和空远程武器 NullRangedWeapon。// 抽象武器接口public interface Weapon { void attack();}// 近战武器public interface MeleeWeapon : Weapon { }public class Sword : MeleeWeapon { public void attack() { Debug.Log(\"使用剑攻击\"); }}public class NullMeleeWeapon : MeleeWeapon { public void attack() { Debug.Log(\"无近战武器\"); }}// 远程武器public interface RangedWeapon : Weapon { }public class Bow : RangedWeapon { public void attack() { Debug.Log(\"使用弓箭攻击\"); }}public class NullRangedWeapon : RangedWeapon { public void attack() { Debug.Log(\"无远程武器\"); }}最后，我们可以在游戏中使用具体的工厂类来创建武器实例并使用它们。// 创建一个近战武器WeaponFactory meleeFactory = new MeleeWeaponFactory();MeleeWeapon meleeWeapon = meleeFactory.CreateMeleeWeapon();// 使用近战武器meleeWeapon.attack();// 创建一个远程武器WeaponFactory rangedFactory = new RangedWeaponFactory();RangedWeapon rangedWeapon = rangedFactory.CreateRangedWeapon();// 使用远程武器rangedWeapon.attack();通过使用抽象工厂模式，我们可以将不同种类的武器的创建和使用代码解耦，使得代码更加灵活、可维护。同时，当需要新增武器类型时，只需要实现相应的工厂类和武器类即可，不需要修改原有的代码。" }, { "title": "Unity自动生成脚本", "url": "/posts/%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%94%B9%E8%84%9A%E6%9C%AC%E5%86%85%E5%AE%B9%E7%9A%84%E6%80%9D%E8%B7%AF/", "categories": "Unity", "tags": "Script, c#", "date": "2023-02-09 09:00:00 +0800", "snippet": "功能实现思路在开发过程当中可能会遇到繁复的修改脚本的操作，有时我们希望可以通过自动化修改脚本内容来避免犯一些人为可能会犯的错误。因此我们希望将增添删除代码的具体内容抽象成一个工具，然后交给非程序的人员也可以进行编写。在确认完需求之后一般我们会将这个工具定位成三步。 读取需要修改的脚本文件，以字符串的方式 正则表达式定位字符串需要修改的位置，通过字符串操作对文本进行拆分，并将要修改的内容进行重组 保存重组修改后的内容类似样例代码实现private void LoadCSharpFileAndReplaceString(string filePath, string methodName) { var cSharpFile = new FileStream(filePath, FileMode.Open); StreamReader read = new StreamReader(cSharpFile); var fileStr = read.ReadToEnd(); read.Close(); File.Delete(filePath); var regexStr = @\"(?&lt;=\" + methodName + @\"\\(\\) {\" + _lineBreak + @\")((\\s.+)?)\"; var regex = new Regex(regexStr); var keepStr1 = fileStr.Substring(0, regex.Match(fileStr).Index); var keepStr2 = fileStr.Substring(regex.Match(fileStr).Index + fileStr.Substring(regex.Match(fileStr).Index).IndexOf(\"}\", StringComparison.Ordinal)); string replaceStr = filePath == PatchVersionFilePath ? $\" return \\\"{CurrentPatchVersion}\\\"; //{PatchMessage}{_lineBreak} \" : $\" return {CurrentNetVersion}; //{NetMessage}{_lineBreak} \"; StringBuilder stringBuilder = new StringBuilder(); stringBuilder.Append(keepStr1); stringBuilder.Append(replaceStr); stringBuilder.Append(keepStr2); fileStr = stringBuilder.ToString(); FileStream file = new FileStream(filePath, FileMode.CreateNew); StreamWriter streamWriter = new StreamWriter(file); streamWriter.Write(fileStr); streamWriter.Flush(); streamWriter.Close(); file.Close(); AssetDatabase.SaveAssets(); AssetDatabase.Refresh(); }代码分为三小段应该能够很好的理解内容。 这里踩过的一个坑是字符串的一些特殊符号一般根据平台有两种读取形式，CRLF和LF，具体的区别会在下文进行解释。Different between CRLF,LF and CR line break types内容参考Stackoverflow一篇回答CR 和 LF 都是控制字符(control characters)，编码分辨是0x0D(十三进制)和0x0A(十进制)他们用来标识在文本当中的换行符，Windows通常使用两个字符CRLF序列，Unix使用LF以及MacOS使用CR CR：Carriage Return，对应ASCII中转义字符\\r，表示回车 LF：Linefeed，对应ASCII中转义字符\\n，表示换行 CRLF：Carriage Return &amp; Linefeed，\\r\\n，表示回车并换行据野史记载，在很久以前的机械打字机时代，CR和LF分别具有不同的作用：LF会将打印纸张上移一行位置，但是保持当前打字的水平位置不变；CR则会将“Carriage”（打字机上的滚动托架）滚回到打印纸张的最左侧，但是保持当前打字的垂直位置不变，即还是在同一行。当CR和LF组合使用时，则会将打印纸张上移一行，且下一个打字位置将回到该行的最左侧，也就是我们今天所理解的换行操作。随着时间的推移，机械打字机渐渐地退出了历史舞台，当初的纸张变成了今天的显示器，打字机的按键也演变为了如今的键盘。在操作系统出现的年代，受限于内存和软盘空间的不足，一些操作系统的设计者决定采用单个字符来表示换行符，如Unix的LF、MacIntosh的CR。他们的意图都是为了进行换行操作，只是当初并没有一个国际标准（或者其他原因，鬼知道），所以才有这样字符上的不同。" }, { "title": "Electron编写服务器学习总结", "url": "/posts/ElectronLearningSummary/", "categories": "Electron", "tags": "web, electron, server", "date": "2023-01-29 09:00:00 +0800", "snippet": "学习资源相关文档地址Electron官方文档Web学习相关知识Node.Js相关文档需求清单 使用Electron框架编写服务器，通过http来进行访问 服务器可以自助打开或者关闭，当关闭时游戏客户端请求开启服务会返回False关键概念Electron框架Electron是一个使用 JavaScript、HTML 和 CSS 构建桌面应用程序的框架。嵌入 Chromium 和 Node.js 到 二进制的 Electron 允许您保持一个 JavaScript 代码代码库并创建 在Windows上运行的跨平台应用 macOS和Linux——不需要本地开发 经验。package.json在初始化并且安装完 Electron 之后，您的 package.json 应该长下面这样。 文件夹中会出现一个 node_modules 文件夹，其中包含了 Electron 可执行文件；还有一个 package-lock.json 文件，指定了各个依赖的确切版本。您在 package.json 中指定的脚本文件 main 是所有 Electron 应用的入口点。 这个文件控制 主程序 (main process)，它运行在 Node.js 环境里，负责控制您应用的生命周期、显示原生界面、执行特殊操作并管理渲染器进程 (renderer processes)因为 Electron 的主进程是一个 Node.js 运行时，您可以使用 electron 命令执行任意 Node.js 代码（甚至将其用作 REPL）。 要执行这个脚本，在 package.json 的 scripts 字段中添加一个 start 命令，执行内容为 electron . 。 这个命令会告诉 Electron 在当前目录下寻找主脚本，并以开发模式运行它。{ \"name\": \"my-electron-app\", \"version\": \"1.0.0\", \"description\": \"Hello World!\", \"main\": \"main.js\", \"author\": \"Jane Doe\", \"license\": \"MIT\", \"scripts\": { \"start\": \"electron .\" }, \"devDependencies\": { \"electron\": \"^19.0.0\" }}BrowserWindow在 Electron 中，每个窗口展示一个页面，后者可以来自本地的 HTML，也可以来自远程 URL。窗口的生命周期时通过监听app和BrowserWindow模块的事件来自行的自定义窗口。preLoad预加载脚本Electron拥有两类进程，一类是主进程，一类是渲染进程，渲染进程默认在网页页面上。因此当我们希望两个进程之间变量可以互相通信的时候，就需要使用preload脚本来进行预加载。在BrowserWindow构造器中传入脚本的的路径来进行使用。在preload脚本当中，我们在脚本内定义全局变量，新建renderer脚本，通过DOM接口来替换HTML元素的显示文本。具体内容可以看文章最上面的官网示例。主进程和渲染进程之间有着清楚的分工，因此如果我们想要在进程直接互相访问接口则需要使用Electron的ipcMain模块和ipcRenderer模块来进行进程之间的通信。为了从你的网页向主进程发送消息，你可以使用 ipcMain.handle 设置一个主进程处理程序（handler），然后在预处理脚本中暴露一个被称为 ipcRenderer.invoke 的函数来触发该处理程序（handler）。因此我们可以在renderer脚本当中调用在preload脚本当中暴露的接口，其返回值和逻辑在主进程当中设置handle监听器来确定。" }, { "title": "Meta文件详解", "url": "/posts/MetaFile/", "categories": "Unity", "tags": "meta, guid, file", "date": "2023-01-03 09:00:00 +0800", "snippet": "在Unity当中，当我们将一个资源导入到项目中，Unity将会执行几个操作。 赋予这个资源一个唯一的ID 对资源进行不同的处理 创建一个同名的.meta伴生文件，记录1，2步的信息Meta文件解析以下是一个常用的.meta文件用文本文件打开后的样子。fileFormatVersion: 2guid: 374a5cce332c141b1af97e408b4bf3b4NativeFormatImporter: externalObjects: {} mainObjectFileID: 100100000 userData: assetBundleName: assetBundleVariant: 在上面这个文件当中，比较重要的信息就是我们上文说的资源的ID和ImportSetting，我们也将从这两部分来进行了解。GUID当一个文件或者一个文件夹导入到Unity的Asset文件夹的时候，我们会给这个资源一个独特的Id，被称为guid，在Unity当中我们确认资源身份不是靠资源路径也不是靠资源名称而是这个guid，这样的做的目的是，即使一个资源重命名了，或者更改了路径，游戏之间已经存在的引用关系不会因此而被破坏，增加了开发过程中的稳定性。但是一个guid只对应一个资源，可是像是图集这类的资源里面有很多子资源就无法用guid来确定，Unity会自动为这些子资源创建LocalId，如下图所示。fileFormatVersion: 2guid: 76f3ef1aba5e2e0408f32a9140fbacd7TextureImporter: internalIDToNameTable: - first: 213: 21300000 second: fising_indicator_shadow_0 - first: 213: 21300002 second: fising_indicator_shadow_1 - first: 213: 21300004 second: fising_indicator_shadow_2因此，当我们使用版本控制工具，比如svn和git来进行开发时，要特别关注meta文件guid的更改，很多文件的引用丢失都是由于guid的更改而造成的。ImportSetting在Unity当中每一个资源导入需要进行不同的处理，例如对一个纹理文件和对一个CS文件处理的方式是不同的，因此Unity为我们集成了多种的内置导入器（ImportSetting)以下是一个Font资源的.meta文件中关于ImportSetting的内容，其中的大部分内容都可以在Inspector窗口进行查看。这些记录的数据代表着Unity对这个Font资源进行的处理的参数，由此我们可以知道，如果我们想在不同的项目中传资源且希望能够统一格式，可以同时将资源以及它的.meta文件一起进行传送。无论是纹理的切片还是Fbx文件的裁剪都可以保留不用进行二次处理。TrueTypeFontImporter: serializedVersion: 2 fontSize: 16 forceTextureCase: -2 characterSpacing: 1 characterPadding: 0 includeFontData: 1 use2xBehaviour: 0 fontNames: [] fallbackFontReferences: [] customCharacters: fontRenderingMode: 0 userData: assetBundleName: assetBundleVariant: 参考文章Unity官网资源元数据UInity文件系统的导入" }, { "title": "Addressable介绍以及使用", "url": "/posts/AssetBundleAddressableResources%E8%B5%84%E6%BA%90/", "categories": "Unity", "tags": "AssetBundle, Addressable, ‘Resources’", "date": "2022-12-07 09:00:00 +0800", "snippet": "相关链接讲解Unity从Resource到AssetBundleAddressables官方文档" }, { "title": "HashCode", "url": "/posts/HashCode/", "categories": "Unity", "tags": "HashCode", "date": "2022-11-29 09:00:00 +0800", "snippet": "原文链接什么是HashCodeHashCode可以理解成是用来标识某件东西的唯一标识符我是一名侦探，正在寻找罪犯。让我们称他为 Mr Cruel。 Mr Cruel有一些特殊的特征，我可以用来在茫茫人海中唯一地识别他。我们在澳大利亚有2500万人。其中之一是 Mr Cruel。我们怎么能找到他？识别 Mr Cruel的坏方法显然， Mr Cruel有一双蓝眼睛。这并没有多大帮助，因为澳大利亚几乎一半的人口也有蓝眼睛。识别残忍先生的好方法我还可以使用什么？我知道：我会使用指纹！优点： 两个人真的很难有相同的指纹（不是不可能，但极不可能） Mr Cruel的指纹永远不会改变 Mr Cruel整个存在的每一个部分：他的外表，头发颜色，个性，饮食习惯等都必须（理想地）反映在他的指纹中，这样如果他有一个兄弟（非常相似但不相同） - 那么两者都应该有不同的指纹。我说“应该”，因为我们不能100%保证这个世界上的两个人会有不同的指纹 但我们总是可以保证， Mr Cruel将永远有相同的指纹 - 并且他的指纹永远不会改变上述特征通常可以产生良好的哈希函数：对于给定的输入，我们想要一个唯一的输出 - 每次都相同的输出;如果我们稍微改变输入，那么我们应该得到一个完全不同的输出。hashFunction(\"1234\") =&gt; \"ABCD\" outputhashFunction(\"1235\") =&gt; \"KDSL\" output什么是冲突（Collision）所以想象一下，如果我得到一个线索，我发现有人与 Mr Cruel的指纹相匹配。这是否意味着我找到了残忍先生？……..也许！我必须仔细看看。如果我正在使用 SHA256（哈希函数）并且我正在寻找一个只有 5 人的小镇 - 那么我很有可能找到他！但是，如果我使用 MD5（另一个著名的哈希函数）并在一个拥有 +2^1000 人的城镇中检查指纹，那么两个完全不同的人可能具有相同的指纹的可能性相当大。HashCode到底有什么好处呢哈希代码的唯一真正好处是如果你想把一些东西放在哈希表中，使用哈希表你想快速找到对象，这就是哈希代码的用武之地。它们允许您非常快速地在哈希表中查找内容。这是一个可以大幅提高性能的方法，但以很小的准确性为代价。因此，让我们想象一下，我们有一个充满人的哈希表——澳大利亚有2500万嫌疑人。 Mr Cruel就在那里的某个地方…..我们怎样才能很快找到他？我们需要对它们进行分类：找到潜在的匹配，或者以其他方式宣告潜在的嫌疑人无罪。你不想考虑每个人的独特特征，因为这会花费太多时间。你会用什么来代替？你会使用哈希码！哈希码可以告诉您两个人是否不同。Joe Bloggs是否是 Mr Cruel。如果指纹不匹配，那么你就知道这绝对不是 Mr Cruel。但是，如果指纹确实匹配，那么根据您使用的哈希函数，您找到您的男人的可能性已经相当大。但这不是100%。您唯一可以确定的方法是进一步调查： 他/她是否有机会/动机 证人等当您使用计算机时，如果两个对象具有相同的哈希代码值，那么您再次需要进一步调查它们是否真正相等。例如，您必须检查对象是否具有相同的高度，相同的重量等，如果整数相同，或者customer_id是否匹配，然后得出结论它们是否相同。这通常可以通过实现IComparer或IEquality接口来完成。HashCode总结 两个相同的对象一定拥有相同的HashCode 拥有相同HashCode的不一定是同一个对象，所以我们除了匹配HashCode之外，我们还需要重写Equality函数" }, { "title": "ADB自动测试工具", "url": "/posts/ADBAutoTestTool/", "categories": "ADB", "tags": "adb, Android", "date": "2022-11-29 09:00:00 +0800", "snippet": "目的是因为游戏发包时，可能由于更改了SDK导致游戏稳定性变差，会导致Crash或者ANR的出现,因此需要制作一款工具去完成自动打开应用并根据关键信息收集日志的工具。ADB需要用的指令adb devices //检查是否有设备进行连接启动Android Appadb shell am start -n [PACKAGE-NAME]/[ACTIVITY-NAME]其中PACKAGE-NAME的参数部分，也就是App的package name，也可以透过以下的指令来进行查看adb shell pm list packages （-s：列出系统应用包名 -3：列出第三方应用包名 -f：列出应用包名及对应的apk名及存放位置 -i：列出应用包名及其安装来源）接着ACTIVITY-NAME可以通过以下指令查看，当前运行App的Activity的名称。adb shell dumpsys activity举个例子，假设手机里装上了一款“元气骑士”，我们通过更改上面提到的例子，得到了游戏的包体名称“com.knight.union.bili”，接着我们打开元气骑士的App后，执行adb shell dumpsys activity指令，我们在输出的log中寻找包体的关键字，就可以找到如下关键字com.knight.union.bili/com.chillyroomsdk.bilibili.PrivacyActivity这个关键字就是我们当前游戏初始画面的Activity了。所以结合上面的几个代码，我们就可以通过下面这一行的指令顺利的启动我们的App。adb shell am start -n com.knight.union.bili/com.chillyroomsdk.bilibili.PrivacyActivity获取界面UI控件信息并模拟点击可以在Python当中导入Poco库，Poco库当中封装好了一些定位UI的方法,最常用方便的是用Text来进行定位from poco.drivers.android.uiautomation import AndroidUiautomationPocoif __name__ == '__main__': poco(text=\"元气骑士\").click() 有时候会遇到devices lineoff的情况，一般用重启手机设备，或重启adb server的方式可以解决除此之外，网易所提供的Airtest工具也提供了一个完整的自动测试环境来协助我们对设备进行UI层面的控制。使用Python制作的完整的监控关键词工具import datetimeimport osimport subprocessimport threadingimport jsonimport sysLOG_PATH = \"\"KEYWORDS = []STOP_LOGCAT = TrueINSTRUCTION = { \"1\": \"filter_keywords\", \"2\": \"stop_filter_keywords\", \"3\": \"exit\"}def filter_keywords(): global STOP_LOGCAT STOP_LOGCAT = False devices = get_devices() # 先获取所有连接的设备 print(\"开始监控关键字\") for device in devices: t = threading.Thread(target=filter_keyword, args=(device,)) t.start()def stop_filter_keywords(): global STOP_LOGCAT if STOP_LOGCAT: print(\"没有正在执行的任务\\n\") else: STOP_LOGCAT = True print(\"正在停止关键字监控\\n\")def filter_keyword(device): print(\"设备%s关键字监控已开启\" % str(device)) sub = logcat(device) with sub: for line in sub.stdout: # 子进程会持续输出日志，对子进程对象.stdout进行循环读取 for key in KEYWORDS: if line.decode(\"utf-8\").find(key) != -1: message = \"设备：%s 检测到：%s 日志信息：%s\\n\" % (device, key, line) path = get_log_path(\"bugreport\") bugreport(device, path, message) print(message) if STOP_LOGCAT: break print(\"设备%s关键字监控已停止\" % str(device)) sub.kill()def logcat(device): command = \"adb logcat -c\" subprocess.call(command) command = \"adb -s \" + str(device) + \" logcat -v time *:W\" sub = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) return subdef get_devices(): command = \"adb devices\" res = os.popen(command).read() devices = [] res = res.split(\"\\n\") for i in res: if i.endswith(\"device\"): devices.append(i.split('\\t')[0]) return devicesdef bugreport(device, path, message): os.chdir(path) year = datetime.datetime.now().strftime('%Y') month = datetime.datetime.now().strftime('%m') day = datetime.datetime.now().strftime('%d') command = \"adb -s \" + str(device) + \" bugreport\" subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, bufsize=-1) print(\"设备：%s 日志路径：%s\" % (str(device), path)) keyword_logcat = open(\"keyword_logcat%s-%s-%s.txt\" % (year, month, day), \"a\") keyword_logcat.write(message) keyword_logcat.close()def get_log_path(tag): year = datetime.datetime.now().strftime('%Y') month = datetime.datetime.now().strftime('%m') day = datetime.datetime.now().strftime('%d') path = os.path.join(LOG_PATH, tag, \"%s %s %s\" % (year, month, day)) if not os.path.exists(path): os.makedirs(path) return pathdef read_config(): f = open('SDKTestConfig.json') data = json.load(f) for i in data['KEYWORDS']: KEYWORDS.append(i['word']) global LOG_PATH LOG_PATH = os.path.join(data['LOG_PATH']) print(LOG_PATH) return datadef main(): read_config() while True: print(\"-\" * 100) print(\"1：开启关键字监控 2：停止关键字监控 3:exit\") print(\"-\" * 100) instruction = str(input(\"\\n请输入要进行的操作号:\")) print(\"-\" * 100) while instruction not in INSTRUCTION.keys(): instruction = str(input(\"\\n输入无效，请重新输入:\")) if int(instruction) == 3: stop_filter_keywords() sys.exit(0) # exit() eval(INSTRUCTION[str(instruction)] + \"()\")if __name__ == '__main__': main()以下是Json的配置文件，主要配置关键词以及logcat的输出路径{ \"KEYWORDS\" : [ {\"word\" : \"ANR\"}, {\"word\" : \"NullPointerException\"}, {\"word\" : \"CRASH\"}, {\"word\" : \"Force Closed\"}, {\"word\" : \"ab\"} ], \"LOG_PATH\" : \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\SDKTestTool\"}参考文章： 如何使用Adb-command-line启动AndroidApp Android原生App UIPoco库" }, { "title": "Unity Eitor扩展 -- MenuItem", "url": "/posts/MenuItem/", "categories": "Unity", "tags": "UnityEditor, 编辑器", "date": "2022-11-25 09:00:00 +0800", "snippet": "MenuItem是在UnityEditor命名空间下的一个类，它允许你可以在Unity编辑器中添加自定义的菜单，同时也可以允许添加快捷键。基本的菜单设置MenuItem只适用于静态static方法，这个属性可以让静态方法转变为菜单指令。下图代码可以让Dosomething方法添加到MyMenu/Do something菜单当中。[MenuItem(\"MyMenu/Do Something\")]static void DoSomething(){ Debug.Log(\"Doing Something...\");}添加菜单快捷键如果想让这个方法通过快捷键来进行调用，则可以在字段最后空一格，输入相应的快捷键操作，例如将这个方法的快捷键设置成ctrl+shift+q，如下图代码所示 必须要空一格才能识别快捷键[MenuItem(\"MyMenu/Do Something %#q\")]static void DoSomething(){ Debug.Log(\"Doing Something...\");}以下是不同快捷键所对应的字符： % (ctrl on Windows and Linux, cmd on macOS) ^ (ctrl on Windows, Linux, and macOS) # (shift) &amp; (alt) 添加Comoponent菜单快捷键除了在Editor的编辑器的菜单栏上添加，还可以在组件的菜单栏上面进行添加，如图上代码所示,代码里演示了如何将一个static方法添加的组件菜单当中。[MenuItem(\"CONTEXT/Rigidbody/Double Mass\")]static void DoubleMass(MenuCommand command){ Rigidbody body = (Rigidbody)command.context; body.mass = body.mass * 2; Debug.Log(\"Doubled Rigidbody's Mass to \" + body.mass + \" from Context Menu.\");}UnityRigidbody示意图MenuItem不同参数的含义以及用法除此之外，MenuItem其实一共有三个参数 ItemName 设置菜单的位置以及快捷键的设置 isValidateFunction 当设置为true时，函数将会在具有相同ItemName的方法前调用 priority 优先级的设置，越小优先级级越高 以下是一个具体的例子，来解释了第二个参数isValidateFunction的用法 [MenuItem(\"Example/Example1\", true)] public static bool Example2() { return Selection.activeGameObject != null; } [MenuItem(\"Example/Example1\", false)] public static void Example1() { Debug.Log(Selection.activeGameObject.name); }这是第二个参数的常用用法，通过判断是否选择了一个GameObject来判断这个菜单栏是否可以被点击，return为true时可以被点击，为false时不可以被点击。其中Example2函数中的代码会在两个地方进行回调，一个是关闭菜单栏的时候，一个是点击菜单栏的时候。第三个参数priority非常好理解，在相同路径的菜单栏下，priority越小，其位置越靠上。 注意：当两个菜单之间的priority相差10以上的时候，彼此之间会自动产生分隔行" }, { "title": "Update And FixedUpdate", "url": "/posts/UpdateAndFixedUpdate/", "categories": "Unity", "tags": "Update, FixUpdate", "date": "2022-11-11 09:00:00 +0800", "snippet": "如果你已经接触过Unity的脚本，你一定对 Update() 函数感到很熟悉，因为我们游戏的大部分逻辑都将在这个方法里面实现。如果你接触Unity有一段时间，那么你大概率会接触到 FixedUpdate()方法。相对于Update的每一帧进行执行，FixedUpdate()的调用采用的是完全独立的计时器，这个独立的计时器将于Unity的物理系统同步。因此，我们常常将使用Rigidbody的逻辑放置在FixedUpdate中进行调用。例如向物体施加力，移动或者跳跃等操作。以上可能是选择何时使用不同的Update方法的结论，但是你最好要了解其背后发生的原理，以及如果不正确的使用会发生什么样的后果。FixedUpdate的运行原理因为FixedUpdate由于使用的是独立的计时器来进行调用，因此在一帧的时间内，FixedUpdate有可能调用一次，两次，或者是一次都不调用，这完全取决于游戏的帧率。举个例子，假如游戏的运行速率是60帧每一秒，而FixedUpdate运行是40次每一秒的话，这意味着，总有20帧的时候，游戏并不会运行FixedUpdate的逻辑，如下图所示。同样的，假如游戏运行的速率是30帧每一秒的话，而FixedUpdate运行是50次每一秒的话，代表每秒至少有20帧执行调用两次FixedUpdate。听完上面两段描述，你可能会认为，FixedUpdate的执行顺序也是根据游戏运行的帧率来进行的，但Unity的脚本生命周期则不是这样，而是按照特定的逻辑来进行运行。在一个完整的脚本周期当中，FixedUpdate永远先于Update进行调用，但是在执行里面步骤之前需要进行时间上的判断。 首先Unity会计算两帧之间的间隔DeltaTime，然后将其加到总时间Time内 然后Unity会对FixedTime进行判断，判断其落后于Time的时间是否小于FixedUpdate的执行间隔FixedDeltaTime（默认是0.02s） 如果落后的时长大于执行间隔则会对FixedUpdate进行调用，并将执行间隔FixedDeltaTime加到总时长FixedTime里面，之后再执行步骤二 如果落后的时长小于执行间隔，则会按顺序调用Update，并重复步骤一如何修改FixedUpdate的速率在Unity当中我们可以点击Project Setting -&gt; Time -&gt; FixedTime Step来进行控制。如图所示。或者我们可以在脚本中用代码进行控制。Time.fixedDeltaTime = 1 / 50;//0.02sFixedUpdate速率在不同情况可能遇到的问题和好处FixedUpdate速率过慢当FixedUpdate的速率在10帧每秒的时候，如果我们将控制人物移动的代码放在FixedUpdate当中进行实现，就会发现物体移动起来会十分的生涩。且由于每一秒只对FixedUpdate进行10次的调用，物理引擎只能用更少的数据来进行计算，因此精度会降低。但于此相反的是，我们的整个游戏的性能开销则会有显著的提升。FixedUpdate速率过快和上面所说的一样，当FixedUpdate速率过快的时候，物体移动起来会更加的流畅，且每一秒钟调用的次数越多，所获得的数据越多，处理的精度就会越高。但是游戏的性能开销则会有着显著的提升。甚至在极端情况下可能会导致游戏直接崩溃的情形。原因是因为，游戏运行的帧率很大程度的取决于CPU的计算量，计算量越高，帧率越小，因此当我们的FixedUpdate速率过高时，每一帧将会多次执行我们的物理逻辑，从而导致计算量过大，所以在下一帧的时候，我们的帧率则会下降，但是当帧率下降的时候，我们又需要调用更多的FixedUpdate来追赶上FixedTime和Time之间的距离，参考上面提到的FixedUpdate的运行原理，所以就会形成恶性循环，当这样恶性循环持续一段时间后，Unity会因为过于卡顿而导致游戏的崩溃。但是Unity显然也不会允许这样的事情发生，所以在刚刚提到的菜单的第二行。也就是Maximum Allowed Timestep当中，我们可以设置FixedUpdate调用的最大速率，从而防止我们因为物理引擎导致的计算量的无限增长。该把哪些东西放在FixedUpdate当中一般来说，将物体通过刚体的方式进行移动的逻辑，以及持续施加力的逻辑是要放到FixedUpdate里面的，这样可以与Unity的物理系统保持一致，即使游戏突然卡了，导致帧率下滑，也能保证基于物理的移动操作是保持同步的，因为FixedUpdate的调用频率是绝对的。而对于单次的力的施加，或者说基于物理逻辑的判断，比如说射线检测放在Update当中进行更新是完全没有问题的。" }, { "title": "UML图之类图", "url": "/posts/UMLClass/", "categories": "UML", "tags": "UML, Class, 类图", "date": "2022-11-07 09:00:00 +0800", "snippet": "类图是软件工程的统一建模语言,是一种静态结构图，该图描述了系统的类集合，类的属性和类之间的关系。类图是面向对象式的建模。他们一般都被用于概念建模（conceptual modelling）的系统分类的应用程序，并可将模型建模转译成代码。 如何表示一个类 在UML类图中表示具体类具体类在类图中用矩形框表示，矩形框分为三层：第一层是类名字。第二层是类的成员变量；第三层是类的方法。再下图当中我们可以发现在成员函数和方法前有着不同的符号，分别代表着不同的权限。 + 代表 public - 代表 private # 代表 protectedc#代码示例：public class Player{ private Weapon _sword; private Weapon _gun; public Weapon CreateSword(){ } public Weapon CreateGun(){ }}uml类图示例 如何表示一个抽象类抽象类和具体类的区别在于是否用斜体来进行表示，抽象方法也是同理。c#代码示例：public abstract class Player{ private Weapon _sword; private Weapon _gun; public abstract Weapon CreateSword(){ } public Weapon CreateGun(){ }}uml类图示例 如何表示一个接口接口也是作为矩形框表示，但是只有两层，第一层用&lt;&lt;interface&gt;&gt;来进行标识，第二层是接口的方法，如果你不了解什么是接口，你可以去看我的关于接口的视频public interface Player{ public Weapon CreateSword(){ } public Clothes CreateClothes(){ }}uml类图示例 如何表示类之间的关系 Inheritance继承关系实线的空心箭头一般用于表示类和类之间的继承关系。以及接口和接口之间的继承关系虚线的空心箭头一般表现类实现接口的关系。![]上方表示继承关系，下方表示实现关系 Association关联关系关联关系指一个对象知道另外一个对象的属性和方法。具体的表现形式位一个对象含有另一个对象的引用。如下图代码示例，玩家包含了对武器类的引用。就可以称玩家和武器之间事关联关系。public class Player{ public Weapon weapon;}一般用实线线性箭头来表示，箭头上方还会有多重性的表达式，用来表现引用的数量，不同表达式所表达的含义如下图所示。 数字:代表精确的数量 *或者0..*:表示具有0到多个引用 0..1：表示只存在一个引用或者空引用 1..*：表示一个或者多个引用 Dependency依赖关系依赖关系是一种弱关联关系，理解为两个对象之间存在引用但这种引用不是作为成员变量而是作为局部变量，或者方法参数，方法返回值等形式存在。一般用虚线线性箭头来进行表示。 组合关系（Composition）聚合关系（Aggregation）组合关系和聚合关系是关联关系的特例，除了拥有关联关系的特点之外，聚合关系还表示两个对象之间具有着“has a”的关系，部分和整体的关系可以分割，部分可以给其他整体共享，就像公司部分和公司员工之间的关系，员工可以存在在不同的部门，即使被单个部门裁员也可以转去别的部门。一般用空心菱形来表示，菱形在整体的那一方。组合模式则是代表着“contain a”的关系，强调的是整体和部分不可分割，例如人和眼睛的关系，两者不可分割。一般用实心菱形来表示，菱形在整体的那一方。但在实际开发过程中一般很难进行判断，通常我们认为整体一消失，部分也消失的就是组合模式，否则则是聚合模式。" }, { "title": "帧同步和状态同步", "url": "/posts/LockStep/", "categories": "帧同步, 状态同步", "tags": "帧同步, 状态同步", "date": "2022-10-25 09:00:00 +0800", "snippet": "在多人联机得网络游戏当中，我们需要使用网络同步来保证每一台机器的游戏表现完全一致。例如在英雄联盟当中，我们需要在十位玩家的显示屏上显示相同的英雄位置，技能释放角度，和技能特效。同步机制的最终目的都为为了达到实时的同步不同客户端状态的目的。同步游戏数据包括但不限于：技能逻辑、普攻、属性、伤害、移动、AI、检测、碰撞等等。现在网络同步按照大类分有两种做法，帧同步和状态同步。 帧同步 Lockstep帧同步的运作模式是，游戏的所有逻辑在客户端，客户端按照一定的逻辑帧向服务器上传操作指令，服务器收到操作指令后将其传递给其余的客户端。 注意，如果不是转发操作，而是每一帧进行状态的同步，那么这里也认为是状态同步。其余的客户端收到指令之后，如果计算的过程一致，接收到的指令一致，那么计算结果肯定是一致的，这样就能保证所有的客户端同步，这就是帧同步的基本运行方式。典型的代表游戏是：王者荣耀，NBAOnline，FIFA像这样：但是同样也存在着一些弊端，因为帧同步的战斗逻辑都写在客户端，所以如果修改了客户端的战斗逻辑，就能很轻易的产生加速，透视，自动瞄准等外挂。同时，由于不同机器的浮点数精度存在着不同，对于某些需要大量计算数据的游戏而言，微小的浮点数差距也会带来截然不同的结果，但我们通常会使用定点数来解决。还有由于部分客户端网速较差的影响其他客户端游戏体验的问题，但是也有着很多的优化方案，类似于客户端预执行，渲染逻辑分离等 状态同步状态同步的游戏占主流，但是相对于帧同步而言状态同步开发起来比较的困难。典型的代表游戏：CSGO，守望先锋，LOL，DOTA2状态模式一般的运作模式是：客户端上传操作到服务器，服务器收到后计算游戏行为的各种数据的结果，然后以广播的方式下方这些计算完成的数据，客户端根据接受到的数据显示画面。 状态同步和帧同步对比 状态同步和帧同步最典型的区别是把战斗逻辑写在哪，在客户端的话则是帧同步，在服务端的话则是状态同步 对于FPS之类对于延迟要求较高的游戏而言，基本上使用状态同步，因为帧同步由于其本身的机制，即使优化过后也容易出现卡顿 帧同步开发难度简单，但是后期问题很难进行排查，状态同步开发较为困难，但问题定位比较容易 对于游戏性能而言，由于帧同步的客户端需要完整的跑一遍战斗逻辑，开销相互对来说更大 对于中途加入和短线重连来说，帧同步比较困难，但是状态同步则非常简单，因为在重连时只需要直接创建这些对象，并且同步信息即可" }, { "title": "创建一个本地的Ftp服务器", "url": "/posts/CreateFtpServer/", "categories": "Ftp, Server", "tags": "Ftp, Server", "date": "2022-10-25 09:00:00 +0800", "snippet": "FTP是File Transfer Protocol(文件传输协议)，支持FTP协议的服务器就是FTP服务器。也可以理解为是在互联网上提供文件存储和访问服务的计算机。创建一个FTP服务器FTP服务器的搭建有各种各样的软件，且在不同的操作系统（windows，linux，mac）上都能进行部署，这里我是在Windows的操作系统上进行的部署，用到的软件是FileZilla，是一款免费的Ftp服务器部署软件。可以点击链接去官网进行下载。下载完成之后双击点击安装，基本上一路点击确定就行。点击菜单栏的编辑按钮点击用户，在右边框框内点击添加，设置相应的账号密码,点击左侧的Shared folders，选择作为服务器根节点的文件夹，将文件的权限全部打开。设置完成之后应该是如下图一样。在Unity当中如何链接FTP服务器var request = (FtpWebRequest)WebRequest.Create(\"ftp://192.168.1.51/encrypted_lua.zip\");//向网站发送命令request.Credentials = new NetworkCredential(\"UerName\", \"xxxxxx\");//输入上述步骤对应的用户名以及密码request.Method = WebRequestMethods.Ftp.DownloadFile;var dataSavePath = Application.persistentDataPath + \"/encrypted_lua.zip\";//输入下载下来的数据所储存的位置using var ftpStream = request.GetResponse().GetResponseStream();using Stream fileStream = File.Create(dataSavePath);ftpStream?.CopyTo(fileStream);ftpStream?.Close();fileStream.Close();以上代码就是在Unity当中通过自己编写方法来实现链接FTP服务器并进行下载的步骤" }, { "title": "什么是“Interfaces”以及如何使用", "url": "/posts/Interfaces/", "categories": "Unity, Interfaces", "tags": "Interfaces", "date": "2022-09-22 09:00:00 +0800", "snippet": "在一款普通的RPG游戏当中，玩家常常需要对场景中的物体进行攻击，但一般来说场景中可以攻击的物体有很多，有敌人，有怪物，甚至是建筑，如果我们每次攻击都要判断被攻击的物体是不是上面所说的三类中的一类，将会很难进行管理。因此我们希望可以通过某种方式来对这些可以被玩家攻击到的物体进行一个统一的标识，接口则是处理这类情形最适合的方法。再这篇博客你将学习到以下的内容 什么是Interfaces 如何创建一个Interfaces 在Unity当中应该如何使用Interfaces什么是InterfaceUnity的接口我们可以近似的理解为一个函数列表。当类实现接口的时候，这个类必须公开的包含这些函数，使用与接口中编写的相同的方法名称，相同的参数以及相同的返回类型。接口作为一种约束，让使用它的脚本必须执行在接口内所定义的规则，因此对于一些脚本而言，继承了接口的类可以被近似的看成同一类型的类，即使他们本质上并不同。举个例子，在我们上面提到的RPG游戏的例子，玩家可以对怪物发动攻击，对建筑发动攻击，对敌人发动攻击，我们希望当玩家攻击的时候，被攻击的物体可以依次实现GetHurt()方法，而不必考虑被攻击物体到底是怪物建筑和敌人中的哪一个。因此我们这里将建筑，怪物，敌人统一视作“可以被人物攻击到”的物体。即使建筑，怪物，敌人收到伤害的方式可能不太一样，但是我们任然可以调用一样的函数来进行执行。如何在Unity中创建Interface在Unity当中创建Interface和在Unity当中创建Scripts有着一样的步骤。一般对于Interface的命名开头我们通常以一个大写的I来开头，用interface来表示这个文件是一个接口。public interface ICanHit{}然后我们会在这个接口中声明我们需要使用的方法和变量。在我们这篇文章讲的例子当中，我们希望它拥有GetHurt()的方法，但是你在编写函数方法的时候不需要将函数的权限设置为public，也不用包含函数的主体。就像下面的代码所显示的。public interface ICanHit{ void GetHurt();}对于那些我们希望被视作为“可以被人物攻击到”的物体。我们将他们用语法来实现我们刚刚创建好的接口。public class Enemy : MonoBehaviour, ICanHit{ public void GetHurt(){ //Enemy受到了伤害 }}他必须要像我们在接口中定义的函数那样，具有一样的名字，一样的返回类型，以及可以公开进行访问。但是函数的实现部分是Enemy所独有的，你可以在其中添加动画，血量减少的enmey独有的逻辑。建筑类和怪物类也使用相同的方法来进行继承。所以在Unity当中我们希望当玩家攻击的时候可以通过接口来进行判断物体是否可以被伤害，我们可以使用TryGetComponent来进行实现。public void PlayerAttack(GameObject object){ if(object.TryGetComponent(out ICanHit canHit)){ object.GetHurt(); }}什么时候该使用Interfaceas与接口行为类似的是我们在面向对象编程当中常用的继承。但是两者的工作方式存在着本质的差异，继承更偏向于是一种“是什么”的关系，而接口更偏向于一种“能干什么”的关系。因此对于敌人和可被破坏的建筑来说，除了都可以被玩家攻击到，基本没有其他的共同点，所以这个时候用接口定义他们可以干什么的行为，显然开发起来更加容易。可是如果是一个男哥布林和一个女哥布林，他们除了性别其他行为都是一致的，所以如果这个时候我们使用接口的话需要重复写两次重复的代码，而且当我们需要改变哥布林受伤逻辑的时候，我们需要在两个地方进行修改，大大减缓了我们开发的速度。所以在上面这种情形下，单一的使用接口和单一的使用继承很难满足我们的所有需求，因此最佳的使用方式我们将接口和继承来进行组合使用。像上述例子的男哥布林以及女哥布林都让他们继承于怪物这个基类，然后我们在基类当中实现ICanHurt接口，这样继承于这个基类的子类也会同时实现ICanHurt所定义的方法，而且我们如果需要修改逻辑，也只需要在基类一处地方进行修改。如下图所示如果你看过我在b站上关于组合模式的视频你会很惊喜的发现，接口似乎可以和Unity当中Component一样当作组件，来实现不同行为的组合。其实接口和Unity当中的Component没有什么区别，都可以用来实现设计模式当中的组合模式，两者的区别是，接口将所有的方法和功能都集中在一个脚本当中，但是Component却将不同的行为分开成为两个脚本上来进行实现。因此在使用Component的时候要在脚本之间进行必要的通讯，而接口则不需要进行这种脚本层面的通讯，但是接口很容易将一个类集成十分多复杂的功能。不利于阅读很分模块。两种方式都由其优点以及缺点，需要根据具体的例子来进行不同的选择。" } ]
