<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://wittykyrie.github.io/</id><title>Witty</title><subtitle>A minimal, responsive, and powerful Jekyll theme for presenting professional writing.</subtitle> <updated>2023-03-08T16:56:02+08:00</updated> <author> <name>Witty</name> <uri>https://wittykyrie.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://wittykyrie.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="zh" href="https://wittykyrie.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator> <rights> © 2023 Witty </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>反射 Reflection</title><link href="https://wittykyrie.github.io/posts/%E5%8F%8D%E5%B0%84/" rel="alternate" type="text/html" title="反射 Reflection" /><published>2023-02-27T09:00:00+08:00</published> <updated>2023-03-08T16:52:46+08:00</updated> <id>https://wittykyrie.github.io/posts/%E5%8F%8D%E5%B0%84/</id> <content src="https://wittykyrie.github.io/posts/%E5%8F%8D%E5%B0%84/" /> <author> <name>wittykyrie</name> </author> <category term="Unity" /> <summary> 反射(Reflection)的概念 反射(Reflection)是一种在运行时获取类型信息、动态创建对象、调用方法等操作的机制。在Unity开发过程中，使用反射(Reflection)可以使代码更加灵活和可扩展，例如动态创建对象、动态调用方法和插件化开发等场景。 反射(Reflection)的好处与坏处 反射(Reflection)是一种强大的机制，可以提高代码的灵活性和可扩展性。但是，在使用反射(Reflection)时需要权衡其优缺点，根据具体情况做出选择，并且需要注意使用反射(Reflection)的最佳实践，以确保代码的性能、安全和可读性。 反射(Reflection)的优点 动态加载和实例化对象：使用反射(Reflection)可以在运行时动态地加载和实例化对象，无需在编译时明确指定类型。这样可以提高代码的灵活性和可扩展性，使得代码更加适应变化和复... </summary> </entry> <entry><title>游戏设计模式之工厂模式</title><link href="https://wittykyrie.github.io/posts/Factor-Pattern/" rel="alternate" type="text/html" title="游戏设计模式之工厂模式" /><published>2023-02-20T09:00:00+08:00</published> <updated>2023-02-21T08:56:33+08:00</updated> <id>https://wittykyrie.github.io/posts/Factor-Pattern/</id> <content src="https://wittykyrie.github.io/posts/Factor-Pattern/" /> <author> <name>wittykyrie</name> </author> <category term="Unity" /> <category term="设计模式" /> <summary> 当我们开发游戏时，我们通常需要创建大量的对象。有时候我们需要手动创建这些对象，但是这种方式容易出现错误，而且难以维护和扩展。在这种情况下，工厂模式就变得非常有用。 工厂模式是一种创建型设计模式，用于创建对象，将对象的创建过程封装在一个类中，以便在需要时创建对象。工厂模式可以通过将客户端代码与实际创建对象的过程分离来提高代码的可维护性、可扩展性和可读性。 在游戏开发中，工厂模式通常用于创建不同类型的游戏对象，例如武器、角色、道具等等。 工厂模式的类型 在工厂模式中，通常会使用以下三种类型： 简单工厂模式 简单工厂模式是最基本的工厂模式。在简单工厂模式中，我们只需要一个工厂类，它根据客户端的请求返回一个具体的对象实例。简单工厂模式通常只适用于创建单一的对象类型。 工厂方法模式 工厂方法模式是一种扩展简单工厂模式的模式，它定义了一个工厂方法接口，用于创建对象，这些对象由子类决定实... </summary> </entry> <entry><title>Unity自动生成脚本</title><link href="https://wittykyrie.github.io/posts/%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%94%B9%E8%84%9A%E6%9C%AC%E5%86%85%E5%AE%B9%E7%9A%84%E6%80%9D%E8%B7%AF/" rel="alternate" type="text/html" title="Unity自动生成脚本" /><published>2023-02-09T09:00:00+08:00</published> <updated>2023-02-09T09:00:00+08:00</updated> <id>https://wittykyrie.github.io/posts/%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%94%B9%E8%84%9A%E6%9C%AC%E5%86%85%E5%AE%B9%E7%9A%84%E6%80%9D%E8%B7%AF/</id> <content src="https://wittykyrie.github.io/posts/%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%94%B9%E8%84%9A%E6%9C%AC%E5%86%85%E5%AE%B9%E7%9A%84%E6%80%9D%E8%B7%AF/" /> <author> <name>wittykyrie</name> </author> <category term="Unity" /> <summary> 功能实现思路 在开发过程当中可能会遇到繁复的修改脚本的操作，有时我们希望可以通过自动化修改脚本内容来避免犯一些人为可能会犯的错误。 因此我们希望将增添删除代码的具体内容抽象成一个工具，然后交给非程序的人员也可以进行编写。 在确认完需求之后一般我们会将这个工具定位成三步。 读取需要修改的脚本文件，以字符串的方式 正则表达式定位字符串需要修改的位置，通过字符串操作对文本进行拆分，并将要修改的内容进行重组 保存重组修改后的内容 类似样例代码实现 private void LoadCSharpFileAndReplaceString(string filePath, string methodName) { var cSharpFile = new FileStream(filePath, FileMode.Open); ... </summary> </entry> <entry><title>Electron编写服务器学习总结</title><link href="https://wittykyrie.github.io/posts/ElectronLearningSummary/" rel="alternate" type="text/html" title="Electron编写服务器学习总结" /><published>2023-01-29T09:00:00+08:00</published> <updated>2023-01-29T09:00:00+08:00</updated> <id>https://wittykyrie.github.io/posts/ElectronLearningSummary/</id> <content src="https://wittykyrie.github.io/posts/ElectronLearningSummary/" /> <author> <name>wittykyrie</name> </author> <category term="Electron" /> <summary> 学习资源相关文档地址 Electron官方文档 Web学习相关知识 Node.Js相关文档 需求清单 使用Electron框架编写服务器，通过http来进行访问 服务器可以自助打开或者关闭，当关闭时游戏客户端请求开启服务会返回False 关键概念 Electron框架 Electron是一个使用 JavaScript、HTML 和 CSS 构建桌面应用程序的框架。嵌入 Chromium 和 Node.js 到 二进制的 Electron 允许您保持一个 JavaScript 代码代码库并创建 在Windows上运行的跨平台应用 macOS和Linux——不需要本地开发 经验。 package.json 在初始化并且安装完 Electron 之后，您的 package.json 应该长下面这样。 文件夹中会出现一个 node_modules 文件夹，其中... </summary> </entry> <entry><title>Meta文件详解</title><link href="https://wittykyrie.github.io/posts/MetaFile/" rel="alternate" type="text/html" title="Meta文件详解" /><published>2023-01-03T09:00:00+08:00</published> <updated>2023-01-04T10:36:42+08:00</updated> <id>https://wittykyrie.github.io/posts/MetaFile/</id> <content src="https://wittykyrie.github.io/posts/MetaFile/" /> <author> <name>wittykyrie</name> </author> <category term="Unity" /> <summary> 在Unity当中，当我们将一个资源导入到项目中，Unity将会执行几个操作。 赋予这个资源一个唯一的ID 对资源进行不同的处理 创建一个同名的.meta伴生文件，记录1，2步的信息 Meta文件解析 以下是一个常用的.meta文件用文本文件打开后的样子。 fileFormatVersion: 2 guid: 374a5cce332c141b1af97e408b4bf3b4 NativeFormatImporter: externalObjects: {} mainObjectFileID: 100100000 userData: assetBundleName: assetBundleVariant: 在上面这个文件当中，比较重要的信息就是我们上文说的资源的ID和ImportSetting，我们也将从这两部分来进行了解。 GUID ... </summary> </entry> </feed>
